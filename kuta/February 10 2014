February 10, 2014
20:30 wkmanire: I'm looking for syntax highlighting
20:30 wkmanire: No such feature
20:30 wkmanire: oh well.
20:32 wkmanire: Ok, so you can pass it heirarchical data
20:32 wkmanire: So we need to turn our category list into this structure.
20:33 wkmanire: We need to iterate through each node
20:33 wkmanire: an pull it's name
20:33 wkmanire: then recurse to its children.
20:33 wkmanire: I'm going to be shooting from the hip here so bear with me.
20:34 john: gladly
20:39 john: It's been tough to wrap my head around it.
20:41 wkmanire: *sigh*
20:41 wkmanire: js conventions
20:43 wkmanire: Ta derp!
20:44 wkmanire: Ok, does that code follow?
20:45 wkmanire: I don't know why they thought that having a column layout would be a good idea
20:45 wkmanire: THis should be full-width
20:48 wkmanire: correct
20:48 wkmanire: It will run for 0 iterations
20:48 wkmanire: This is not an optimal solution because we did not write this in tail recursive form.
20:48 wkmanire: No tail-recursion optimization is possible
20:49 wkmanire: However, we have a non-uniform tree structure
20:49 wkmanire: So it is probably not possible.
20:49 john: I'm not familiar with that term
20:49 wkmanire: tail recursion is when the return value of a recursive function is therecursive call.
20:49 wkmanire: the recursive call*
20:50 wkmanire: When you are able to emply tail-recursion
20:50 john: and that is more efficient because the calling instance of the function doesn't have to resume control and do something after the called instance is finished?
20:51 wkmanire: In essnse, yes
20:51 wkmanire: essnse*
20:51 wkmanire: fack
20:51 wkmanire: Most compilers can optimize a tail recursive call into a while loop
20:51 wkmanire: So you can get infinite stack depth without blowing the stack so to speak
20:51 wkmanire: I don't think the browsers do tail-call optimization for Javascript yet
20:52 wkmanire: But it's still a good habit to try and get into.
20:52 wkmanire: You're never going to get more than 10 or 15 levels of recursion here so we don't need to worry about blowing the stack
20:52 john: blowing the stack is a running out of resources or is there another limit?
20:53 wkmanire: "The stack" refers to the frames of memory that the langauge interpreter creates each time you call a function.
20:53 wkmanire: It's like a stack of plates, literallly.
20:53 wkmanire: Where each plate has an ID of where it is in the instructions
20:53 wkmanire: And each plate contains all of the variables that are in scope for that function.
20:54 wkmanire: Each time a function calls a function, the langauge interpreter makes another plate
20:54 john: So in essence you eat up memory
20:54 wkmanire: When a function returns, the plate pops off the stack and the memory is restored to teh system
20:54 wkmanire: the*
20:54 wkmanire: There are 2 kinds of memory that you can use
20:54 wkmanire: Stack space and heap space
20:54 wkmanire: Stack space is limited and can read and write super fast
20:54 wkmanire: Stack space is usually less than a few megabytes
20:55 wkmanire: Heap space is "RAM" and it is limited b how much available ram the computer has.
20:55 wkmanire: When you allocate a variable in javascript it goes into the heap
20:55 wkmanire: And a pointer to where it is on the heap goes onto your "plate"
20:55 wkmanire: for the current stack frame.
20:55 wkmanire: Those pointers take up space.
20:56 wkmanire: So when you recurse too much you run out of stack space and can't allocate any more variables.
20:56 wkmanire: That is all a big aside
20:56 wkmanire: Just thought you might find it interesting.
20:56 wkmanire: It helps to understand what recursive functions are doing.
20:56 wkmanire: When you write code in C or C++ or other low-level languages you have to deal with this shit directly.
20:56 wkmanire: Fortunately, Python and Javascript magic away memory management for us
20:57 wkmanire: WE just have to make smart decisions in our code.
20:57 wkmanire: Alright, so this defines how to do the whole tree.
20:57 wkmanire: Ready to move on to branch loading?
20:57 wkmanire: lazy-loading rather.
20:57 john: Thank you that was very interesting. Another point in the aside, if the heap is RAM, is the stack the cache of the RAM?
20:58 wkmanire: I'm not sure specifically on that
20:58 wkmanire: I think part of the stack is actually buffered on the CPU
20:58 wkmanire: and part of it is in the cache
20:58 wkmanire: Not 100% sure.
20:58 john: Ahh, I didn't even consider that possibility
20:58 john: cool.
20:58 john: Ok ready for lazy loading
20:58 wkmanire: So our lazy loading function is essentially written for us.
20:58 wkmanire: getJQStructureChildren
20:59 wkmanire: All you have to do is pass it the collection and a parentID and you'll get the whole set of children to be bound to the tree
20:59 wkmanire: It will bind as many levels of children that it can find in your collection
20:59 wkmanire: So the trick is to just control how you fill the collection with child nodes.
21:00 wkmanire: So when lazy loading is enabled you have to get the ID of the node the user clicked on first
21:02 wkmanire: Does that make sense?
21:02 john: Yes, this is the node level lazy loading
21:02 wkmanire: Right.
21:03 wkmanire: Now for child paging
21:05 wkmanire: You'll really want to think about where to put this code
21:06 wkmanire: These functions all probably belong on a View
21:06 wkmanire: Or mostly on a View.
21:06 wkmanire: Getting the jqTree structure is just another form of a View if you think about it.
21:06 john: Yes, that was the plan. The view houses the functions and the tree is essentially the view's element
21:06 wkmanire: You need to make sure that you associate enough data with the nodes so that when a node is clicked on
21:07 wkmanire: You can get the parameters together to make your call.
21:07 wkmanire: lazyLoadingEnabled and childPagingEnabled should be members of the TreeView
21:07 wkmanire: The CategoryCollection should be oblivious to this and just get whatever it is instructed to get by the controller/view
21:09 john: For future reference. Each nodes ID is unique, so in the mapping, the data structure will essentially be two unique IDs. So I don't need the mappings to be aware of their depth in the tree or parent nodes, etc?
21:09 wkmanire: Yes
21:09 wkmanire: ANd yes
21:09 wkmanire: You're literally boiling all of this information down to a list of "this id goes to this id"
21:10 wkmanire: At one point in time we attempted to automate this using synonym matching
21:10 wkmanire: couch ~= sofa
21:10 wkmanire: But there is so much variation and special behavior involved that it unfortunately requires a human
21:10 wkmanire: We were only able to guess a very low percentage of the time.
21:10 wkmanire: Because some users will have categories names like:
21:11 wkmanire: ASDJF#@JAF#JAF BLACK ACME RKTS
21:11 john: Well that's not helpful to anybody
21:11 john: That
21:11 wkmanire: Anybody else, the company owners seem to know what it means
21:11 wkmanire: One of our customers has on average 2 products in a category
21:12 wkmanire: But he has over 25,000 products
21:12 wkmanire: So bear in mind, that all of this logic that you'll be doing for loading the CSE categories
21:12 wkmanire: You'll have to apply to the Customer's category tree
21:12 wkmanire: yourcategory
21:12 john: wow. To each their own.
21:13 wkmanire: The category structures are similar enough that you'll be able to reuse these getJQStructure functions on both sides
21:13 wkmanire: Alright then, I have to get back to my stuff here.
21:13 wkmanire: Feel free to beep me if you have any other questions.
21:13 wkmanire: I hope this will give you a big jump start so we can get some progress this week :)
21:13 john: Thank you very much for your help! Everything is alot clearer